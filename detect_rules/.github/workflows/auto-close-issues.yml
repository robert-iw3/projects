name: Auto Close Issues and Add Solved Label

on:
  pull_request:
    types: [closed]
    branches:
      - main
      - test
      - develop
      - 'release/**'
  workflow_dispatch:
    inputs:
      label:
        description: 'Label to apply to closed issues'
        default: 'solved'
        required: false
      branches:
        description: 'Comma-separated list of additional branches to process'
        required: false

jobs:
  process-linked-issues:
    runs-on: ubuntu-latest
    if: github.event.pull_request.merged == true || github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get linked issues and process
        uses: actions/github-script@v7
        id: process-issues
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const core = require('@actions/core');

            try {
              // Get inputs for workflow_dispatch
              const customLabel = "${{ github.event.inputs.label || 'solved' }}";
              const additionalBranches = "${{ github.event.inputs.branches || '' }}".split(',').map(b => b.trim()).filter(b => b);
              const validBranches = ['main', 'test', 'develop', ...additionalBranches, ..."${{ github.event.pull_request.base.ref }}".match(/^release\/.*/)];

              // Check if current branch is valid
              const isValidBranch = validBranches.some(branch => "${{ github.event.pull_request.base.ref }}" === branch || "${{ github.event.pull_request.base.ref }}".match(branch));
              if (!isValidBranch && "${{ github.event_name }}" !== 'workflow_dispatch') {
                core.info('Branch not in valid list, skipping.');
                return;
              }

              // GraphQL query to fetch linked issues
              const query = `
                query ($owner: String!, $repo: String!, $prNumber: Int!) {
                  repository(owner: $owner, name: $repo) {
                    pullRequest(number: $prNumber) {
                      closingIssuesReferences(first: 50) {
                        nodes {
                          number
                        }
                      }
                      body
                    }
                  }
                }
              `;

              const variables = {
                owner: context.repo.owner,
                repo: context.repo.repo,
                prNumber: context.payload.pull_request.number
              };

              // Fetch linked issues
              const result = await github.graphql(query, variables);
              let linkedIssues = result.repository.pullRequest.closingIssuesReferences.nodes.map(issue => issue.number);

              // Parse PR body for issue references
              const prBody = result.repository.pullRequest.body || "";
              const issueRegex = /(?:close|closes|closed|fix|fixes|fixed|resolve|resolves|resolved)\s*#(\d+)/gi;
              const issuesInDescription = [...new Set([...prBody.matchAll(issueRegex)].map(match => parseInt(match[1])))].filter(num => !isNaN(num));

              // Combine and deduplicate issues
              linkedIssues = [...new Set([...linkedIssues, ...issuesInDescription])];
              core.info(`Found issues: ${linkedIssues.join(', ')}`);

              if (linkedIssues.length === 0) {
                core.info('No linked issues found.');
                return;
              }

              // Process each issue
              for (const issueNumber of linkedIssues) {
                try {
                  // Add label
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    labels: [customLabel]
                  });
                  core.info(`Added label '${customLabel}' to issue #${issueNumber}`);

                  // Close issue if on release branch or manual dispatch
                  if ("${{ github.event.pull_request.base.ref }}".startsWith('release/') || "${{ github.event_name }}" === 'workflow_dispatch') {
                    await github.rest.issues.update({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      state: 'closed'
                    });
                    core.info(`Closed issue #${issueNumber}`);
                  }
                } catch (error) {
                  core.warning(`Failed to process issue #${issueNumber}: ${error.message}`);
                }
              }

              core.setOutput('processed_issues', linkedIssues.join(' '));
            } catch (error) {
              core.setFailed(`Action failed: ${error.message}`);
            }