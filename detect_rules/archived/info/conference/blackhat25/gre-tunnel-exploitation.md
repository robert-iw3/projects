### GRE and GRETAP Tunnel Exploitation
---

This report details novel red teaming techniques leveraging IP spoofing against Generic Routing Encapsulation (GRE) and GRETAP tunnels for initial access and evasion. These methods exploit the unencrypted and stateless nature of GRE/GRETAP to bypass network security controls and access internal resources without an initial foothold.

Recent research (January 2025) indicates that millions of internet hosts, including VPN servers and home routers, are vulnerable to exploitation due to critical flaws in common tunneling protocols like GRE/GRE6, IPIP/IP6IP6, and 4in6/6in4. These vulnerabilities, assigned CVEs such as CVE-2024-7595, CVE-2025-23018, CVE-2025-23019, and CVE-2024-7596, allow attackers to hijack affected internet hosts to perform anonymous attacks and gain unauthorized network access by accepting unauthenticated tunneling packets.

### Actionable Threat Data
---

Monitor for GRE and GRETAP traffic with unusual source or destination IP addresses, especially those originating from or destined for public IP ranges that are not explicitly authorized for tunnel endpoints.

Implement ingress and egress filtering on network perimeters to block IP-spoofed packets, particularly those with internal source IP addresses appearing on external interfaces or external source IP addresses claiming to be internal.

Analyze network flow data (e.g., NetFlow) for unexpected GRE/GRETAP tunnel activity, such as new or unapproved tunnel establishments or unusual traffic patterns within existing tunnels.

Look for ICMP packets encapsulated within GRE or GRETAP, especially if the ICMP ID or Sequence fields contain what appears to be IP address information, as this could indicate tunnel scanning or peer identification attempts.

Investigate any attempts to access internal network resources via GRE/GRETAP tunnels from external sources without proper authentication or established VPN connections.

### GRE/GRETAP IP Spoofing
---
Name: Potential GRE/GRETAP IP Spoofing

Description:

Detects potential GRE/GRETAP IP spoofing attacks. Attackers can exploit these tunnels with spoofed IPs for initial access and evasion. This rule looks for GRE traffic (IP protocol 47) where the source IP is an internal, private IP address, but the traffic is communicating with a public IP address. This is a strong indicator of IP spoofing or a significant network misconfiguration, as private IP addresses should not be routable over the public internet.

Tactic: Initial Access, Defense Evasion

Technique: T1595.002 (Active Scanning: Vulnerability Scanning), T1090.002 (Proxy: External Proxy)

Author: RW

Date: 2025-08-13

False Positives: Network misconfigurations could potentially lead to false positives. It's recommended to baseline normal GRE traffic and add exceptions for known, legitimate internal source IPs seen on external interfaces if necessary.

Data Source: Network Session, Firewall Logs

splunk:
```sql
`tstats` summariesonly=true count min(_time) as firstTime max(_time) as lastTime from datamodel=Network_Traffic where All_Traffic.proto_id=47 by All_Traffic.src_ip All_Traffic.dest_ip All_Traffic.user
| `drop_dm_object_name("All_Traffic")`
| `security_content_ctime(firstTime)`
| `security_content_ctime(lastTime)`
-- Filter for private source IPs (RFC1918). This traffic should not be routable on the public internet.
| where cidrmatch("10.0.0.0/8", src_ip) OR cidrmatch("172.16.0.0/12", src_ip) OR cidrmatch("192.168.0.0/16", src_ip)
-- Filter for public destination IPs, excluding other non-routable ranges.
| where NOT (cidrmatch("10.0.0.0/8", dest_ip) OR cidrmatch("172.16.0.0/12", dest_ip) OR cidrmatch("192.168.0.0/16", dest_ip) OR cidrmatch("127.0.0.0/8", dest_ip) OR cidrmatch("169.254.0.0/16", dest_ip) OR cidrmatch("224.0.0.0/4", dest_ip))
-- To reduce false positives, add known legitimate GRE endpoints or misconfigured but benign assets to this allowlist.
-- | where NOT (src_ip IN (...) AND dest_ip IN (...))
-- Add metadata for the alert.
| eval name="Potential GRE/GRETAP IP Spoofing", Tactic="Initial Access, Defense Evasion", Technique="T1595.002, T1090.002"
```

crowdstrike fql:
```sql
Protocol = 47
| cidr(src_ip, "10.0.0.0/8") OR cidr(src_ip, "172.16.0.0/12") OR cidr(src_ip, "192.168.0.0/16")
| not (cidr(dest_ip, "10.0.0.0/8") OR cidr(dest_ip, "172.16.0.0/12") OR cidr(dest_ip, "192.168.0.0/16") OR cidr(dest_ip, "127.0.0.0/8") OR cidr(dest_ip, "169.254.0.0/16") OR cidr(dest_ip, "224.0.0.0/4"))
| groupBy([src_ip, dest_ip, user])
| count() as count, min(@timestamp) as firstTime, max(@timestamp) as lastTime
```

datadog:
```sql
@All_Traffic
.proto_id:47 AND (CIDR(src_ip, "10.0.0.0/8") OR CIDR(src_ip, "172.16.0.0/12") OR CIDR(src_ip, "192.168.0.0/16")) AND NOT (CIDR(dest_ip, "10.0.0.0/8") OR CIDR(dest_ip, "172.16.0.0/12") OR CIDR(dest_ip, "192.168.0.0/16") OR CIDR(dest_ip, "127.0.0.0/8") OR CIDR(dest_ip, "169.254.0.0/16") OR CIDR(dest_ip, "224.0.0.0/4"))
| stats count, min(@timestamp) as firstTime, max(@timestamp) as lastTime by src_ip, dest_ip, user
```

elastic:
```sql
FROM network-traffic*
| WHERE network.iana_number == 47
| WHERE CIDR_MATCH(source.ip, "10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16")
| WHERE NOT CIDR_MATCH(destination.ip, "10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "127.0.0.0/8", "169.254.0.0/16", "224.0.0.0/4")
| STATS COUNT() as count, MIN(@timestamp) as firstTime, MAX(@timestamp) as lastTime BY source.ip, destination.ip, user.id
```

sentinel one:
```sql
EventType = "IP Connect" AND NetProtocolName = "GRE" AND (SrcIP ~= "^10." OR SrcIP ~= "^172.(1[6-9]|2[0-9]|3[0-1])." OR SrcIP ~= "^192.168.") AND NOT (DstIP ~= "^10." OR DstIP ~= "^172.(1[6-9]|2[0-9]|3[0-1])." OR DstIP ~= "^192.168." OR DstIP ~= "^127." OR DstIP ~= "^169.254." OR DstIP ~= "^22[4-9]." OR DstIP ~= "^23[0-9]." OR DstIP ~= "^2[4-5][0-9].")
| STATS COUNT() as count, MIN(EventTime) as firstTime, MAX(EventTime) as lastTime BY SrcIP, DstIP, User
```

### Unusual GRE/GRETAP Traffic
---
Name: Unusual GRE/GRETAP Traffic Detected

Description: Detects GRE/GRETAP network traffic (IP protocol 47), which could indicate the establishment of a new or unauthorized tunnel. Attackers can exploit these tunnels for initial access, data exfiltration, or defense evasion. This rule is intended to be a baseline and should be tuned by adding known, legitimate GRE tunnel endpoints to an allowlist to reduce noise.

Tactic: Initial Access, Defense Evasion

Technique: T1595.002 (Active Scanning: Vulnerability Scanning), T1090.002 (Proxy: External Proxy)

Author: RW

Date: 2025-08-13

False Positives: This rule will trigger on any GRE/GRETAP traffic not on the allowlist. Legitimate uses include site-to-site VPNs, cloud connectivity (e.g., AWS Transit Gateway), and DDoS mitigation services (e.g., Cloudflare Magic Transit). It is critical to populate the 'known_gre_tunnels' list with legitimate tunnel endpoints.

Data Source: Network Session, Firewall Logs

splunk:
```sql
`tstats` summariesonly=true count min(_time) as firstTime max(_time) as lastTime sum(All_Traffic.bytes) as total_bytes from datamodel=Network_Traffic where All_Traffic.proto_id=47 by All_Traffic.src_ip All_Traffic.dest_ip All_Traffic.user
| `drop_dm_object_name("All_Traffic")`
| `security_content_ctime(firstTime)`
| `security_content_ctime(lastTime)`
-- To reduce false positives, add known legitimate GRE tunnel source and destination pairs to this allowlist.
-- For example: `| where NOT ((src_ip="1.1.1.1" AND dest_ip="2.2.2.2") OR (src_ip="2.2.2.2" AND dest_ip="1.1.1.1"))`
| `fill_null_values`
| `eval name="Unusual GRE/GRETAP Traffic Detected", Tactic="Initial Access, Defense Evasion", Technique="T1595.002, T1090.002"`
```

crowdstrike fql:
```sql
Protocol = 47
| groupBy([src_ip, dest_ip, user])
| count() as count, min(@timestamp) as firstTime, max(@timestamp
```

datadog:
```sql
@All_Traffic.proto_id:47
| stats count, min(@timestamp) as firstTime, max(@timestamp) as lastTime, sum(bytes) as total_bytes by src_ip, dest_ip, user
| fill_null user, "unknown"
```

elastic:
```sql
FROM network-traffic*
| WHERE network.iana_number == 47
| STATS COUNT() as count, MIN(@timestamp) as firstTime, MAX(@timestamp) as lastTime, SUM(network.bytes) as total_bytes BY source.ip, destination.ip, COALESCE(user.id, "unknown")
```

sentinel one:
```sql
EventType = "IP Connect" AND NetProtocolName = "GRE"
| STATS COUNT() as count, MIN(EventTime) as firstTime, MAX(EventTime) as lastTime, SUM(NetBytesTotal) as total_bytes BY SrcIP, DstIP, COALESCE(User, "unknown")
```

### Spoofed IP Packet Detection
---
Name: Potential IP Spoofing - Private Source to Public Destination

Description:

Detects network traffic originating from a private (RFC1918) source IP address to a public destination IP address. This pattern is a strong indicator of an IP spoofing attempt or a significant network misconfiguration, as private IP addresses should not be routable on the public internet. This rule is most effective when applied to logs from perimeter network devices (e.g., firewalls, edge routers) that monitor traffic leaving the network.

Tactic: Initial Access, Defense Evasion

Technique: T1595.002, T1090.002

Author: RW

Date: 2025-08-13

False Positives: This rule can be noisy if not scoped to the correct log sources. Legitimate outbound traffic from internal hosts will match this pattern before Network Address Translation (NAT) is applied. It is critical to filter for log sources that are positioned at the network edge to monitor post-NAT or un-NATted egress traffic. Network misconfigurations can also be a source of false positives.

Data Source: Network Session, Firewall Logs

splunk:
```sql
| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Network_Traffic where (All_Traffic.src_ip="10.0.0.0/8" OR All_Traffic.src_ip="172.16.0.0/12" OR All_Traffic.src_ip="192.168.0.0/16") AND NOT (All_Traffic.dest_ip="10.0.0.0/8" OR All_Traffic.dest_ip="172.16.0.0/12" OR All_Traffic.dest_ip="192.168.0.0/16" OR All_Traffic.dest_ip="127.0.0.0/8" OR All_Traffic.dest_ip="169.254.0.0/16" OR All_Traffic.dest_ip="224.0.0.0/4") by All_Traffic.src_ip, All_Traffic.dest_ip, All_Traffic.dest_port, All_Traffic.user
| `drop_dm_object_name("All_Traffic")`
| `security_content_ctime(firstTime)`
| `security_content_ctime(lastTime)`
| `potential_ip_spoofing___private_source_to_public_destination_filter`
| table firstTime, lastTime, src_ip, dest_ip, dest_port, user, count
| `map_summaries_to_fields(dest_ip,_time)`
```

crowdstrike fql:
```sql
(cidr(src_ip, "10.0.0.0/8") OR cidr(src_ip, "172.16.0.0/12") OR cidr(src_ip, "192.168.0.0/16")) AND NOT (cidr(dest_ip, "10.0.0.0/8") OR cidr(dest_ip, "172.16.0.0/12") OR cidr(dest_ip, "192.168.0.0/16") OR cidr(dest_ip, "127.0.0.0/8") OR cidr(dest_ip, "169.254.0.0/16") OR cidr(dest_ip, "224.0.0.0/4"))
| groupBy([src_ip, dest_ip, dest_port, user])
| count() as count, min(@timestamp) as firstTime, max(@timestamp) as lastTime
| select firstTime, lastTime, src_ip, dest_ip, dest_port, user, count
```

datadog:
```sql
(CIDR(src_ip, "10.0.0.0/8") OR CIDR(src_ip, "172.16.0.0/12") OR CIDR(src_ip, "192.168.0.0/16")) AND NOT (CIDR(dest_ip, "10.0.0.0/8") OR CIDR(dest_ip, "172.16.0.0/12") OR CIDR(dest_ip, "192.168.0.0/16") OR CIDR(dest_ip, "127.0.0.0/8") OR CIDR(dest_ip, "169.254.0.0/16") OR CIDR(dest_ip, "224.0.0.0/4"))
| stats count, min(@timestamp) as firstTime, max(@timestamp) as lastTime by src_ip, dest_ip, dest_port, user
| select firstTime, lastTime, src_ip, dest_ip, dest_port, user, count
```

elastic:
```sql
FROM network-traffic*
| WHERE CIDR_MATCH(source.ip, "10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16") AND NOT CIDR_MATCH(destination.ip, "10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "127.0.0.0/8", "169.254.0.0/16", "224.0.0.0/4")
| STATS COUNT() as count, MIN(@timestamp) as firstTime, MAX(@timestamp) as lastTime BY source.ip, destination.ip, destination.port, user.id
| KEEP firstTime, lastTime, source.ip, destination.ip, destination.port, user.id, count
```

sentinel one:
```sql
EventType = "IP Connect" AND (SrcIP ~= "^10." OR SrcIP ~= "^172.(1[6-9]|2[0-9]|3[0-1])." OR SrcIP ~= "^192.168.") AND NOT (DstIP ~= "^10." OR DstIP ~= "^172.(1[6-9]|2[0-9]|3[0-1])." OR DstIP ~= "^192.168." OR DstIP ~= "^127." OR DstIP ~= "^169.254." OR DstIP ~= "^22[4-9]." OR DstIP ~= "^23[0-9]." OR DstIP ~= "^2[4-5][0-9].")
| STATS COUNT() as count, MIN(EventTime) as firstTime, MAX(EventTime) as lastTime BY SrcIP, DstIP, DstPort, User
| SELECT firstTime, lastTime, SrcIP, DstIP, DstPort, User, count
```

### GRE/GRETAP Tunnel Scanning
---
Name: GRE/GRETAP Tunnel Scanning

Description:

Detects potential GRE/GRETAP tunnel scanning activity. Attackers may encapsulate ICMP echo requests within GRE packets, embedding potential peer IP addresses in the ICMP identifier and sequence number fields to discover misconfigured or vulnerable tunnels. This detection looks for a single source sending multiple GRE-encapsulated ICMP echo requests with a high variety of ICMP identifiers or sequence numbers, which is indicative of this scanning technique.

Tactic: Reconnaissance

Technique: T1595.002

Author: RW

Date: 2025-08-13

Data Source: Network Session logs with deep packet inspection (e.g., Zeek, NGFW).

Data Requirement: This query requires fields for encapsulated ICMP Type, Identifier, and Sequence. These are represented as placeholders and may need to be extracted from a dynamic field like 'AdditionalFields'.

False Positives: Medium. Some non-standard network diagnostic tools might use high ICMP identifier or sequence values. The combination of GRE encapsulation and a high volume of varied requests from a single source is highly indicative of scanning. Legitimate, high-volume GRE/ICMP traffic should be investigated and potentially added to an exclusion list.

splunk:
```sql
`tstats` summariesonly=true values(All_Traffic.dest_ip) as dest_ip, values(All_Traffic.icmp_id) as icmp_id, values(All_Traffic.icmp_seq) as icmp_seq, count from datamodel=Network_Traffic where All_Traffic.proto_id=47 AND All_Traffic.icmp_type=8 AND (All_Traffic.icmp_id > 4096 OR All_Traffic.icmp_seq > 4096) by All_Traffic.src_ip, _time span=10m
| `drop_dm_object_name("All_Traffic")`
| `security_content_ctime(_time)`
| rename _time as firstTime
| stats `security_content_summariesonly` sum(count) as event_count, dc(dest_ip) as distinct_dest_count, dc(icmp_id) as distinct_icmp_id_count, dc(icmp_seq) as distinct_icmp_seq_count, values(dest_ip) as targets, values(icmp_id) as icmp_ids, values(icmp_seq) as icmp_seqs by src_ip, firstTime
| where event_count > 10 AND (distinct_icmp_id_count > 5 OR distinct_icmp_seq_count > 5)
| `security_content_ctime(firstTime)`
| eval name="GRE/GRETAP Tunnel Scanning", Tactic="Reconnaissance", Technique="T1595.002"
| table name, Tactic, Technique, firstTime, src_ip, targets, event_count, distinct_dest_count, distinct_icmp_id_count, distinct_icmp_seq_count, icmp_ids, icmp_seqs
```

crowdstrike fql:
```sql
Protocol = 47 AND icmp_type = 8 AND (icmp_id > 4096 OR icmp_seq > 4096)
| groupBy([src_ip, @timestamp], span=10m)
| collect(dest_ip, icmp_id, icmp_seq) as [dest_ip, icmp_id, icmp_seq], count() as count
| rename(@timestamp, firstTime) | groupBy([src_ip, firstTime])
| sum(count) as event_count, distinct_count(dest_ip) as distinct_dest_count, distinct_count(icmp_id) as distinct_icmp_id_count, distinct_count(icmp_seq) as distinct_icmp_seq_count, collect(dest_ip) as targets, collect(icmp_id) as icmp_ids, collect(icmp_seq) as icmp_seqs | filter(event_count > 10 AND (distinct_icmp_id_count > 5 OR distinct_icmp_seq_count > 5))
| select("GRE/GRETAP Tunnel Scanning" as name, "Reconnaissance" as Tactic, "T1595.002" as Technique, firstTime, src_ip, targets, event_count, distinct_dest_count, distinct_icmp_id_count, distinct_icmp_seq_count, icmp_ids, icmp_seqs)
```

datadog:
```sql
@All_Traffic.proto_id:47 @All_Traffic.icmp_type:8 (@All_Traffic.icmp_id:>4096 OR @All_Traffic.icmp_seq:>4096)
| stats by src_ip, @timestamp[10m]
| collect dest_ip as dest_ip, icmp_id as icmp_id, icmp_seq as icmp_seq, count as count
| rename @timestamp as firstTime
| stats sum(count) as event_count, distinct_count(dest_ip) as distinct_dest_count, distinct_count(icmp_id) as distinct_icmp_id_count, distinct_count(icmp_seq) as distinct_icmp_seq_count, collect(dest_ip) as targets, collect(icmp_id) as icmp_ids, collect(icmp_seq) as icmp_seqs by src_ip, firstTime
| where event_count > 10 AND (distinct_icmp_id_count > 5 OR distinct_icmp_seq_count > 5)
| select "GRE/GRETAP Tunnel Scanning" as name, "Reconnaissance" as Tactic, "T1595.002" as Technique, firstTime, src_ip, targets, event_count, distinct_dest_count, distinct_icmp_id_count, distinct_icmp_seq_count, icmp_ids, icmp_seqs
```

elastic:
```sql
FROM network-traffic*
| WHERE network.iana_number == 47 AND network.icmp.type == 8 AND (network.icmp.id > 4096 OR network.icmp.sequence > 4096)
| STATS values(destination.ip) as dest_ip, values(network.icmp.id) as icmp_id, values(network.icmp.sequence) as icmp_seq, COUNT() as count BY source.ip, BUCKET(@timestamp, 10 minutes) AS firstTime
| STATS SUM(count) as event_count, COUNT_DISTINCT(dest_ip) as distinct_dest_count, COUNT_DISTINCT(icmp_id) as distinct_icmp_id_count, COUNT_DISTINCT(icmp_seq) as distinct_icmp_seq_count, values(dest_ip) as targets, values(icmp_id) as icmp_ids, values(icmp_seq) as icmp_seqs BY source.ip, firstTime
| WHERE event_count > 10 AND (distinct_icmp_id_count > 5 OR distinct_icmp_seq_count > 5)
| EVAL name = "GRE/GRETAP Tunnel Scanning", Tactic = "Reconnaissance", Technique = "T1595.002"
| KEEP name, Tactic, Technique, firstTime, source.ip, targets, event_count, distinct_dest_count, distinct_icmp_id_count, distinct_icmp_seq_count, icmp_ids, icmp_seqs
```

sentinel one:
```sql
EventType = "IP Connect" AND NetProtocolName = "GRE" AND ICMPType = 8 AND (ICMPID > 4096 OR ICMPSeq > 4096)
| STATS COLLECT(DstIP) as dest_ip, COLLECT(ICMPID) as icmp_id, COLLECT(ICMPSeq) as icmp_seq, COUNT() as count BY SrcIP, BUCKET(EventTime, 10m) AS firstTime
| STATS SUM(count) as event_count, DISTINCT_COUNT(dest_ip) as distinct_dest_count, DISTINCT_COUNT(icmp_id) as distinct_icmp_id_count, DISTINCT_COUNT(icmp_seq) as distinct_icmp_seq_count, COLLECT(dest_ip) as targets, COLLECT(icmp_id) as icmp_ids, COLLECT(icmp_seq) as icmp_seqs BY SrcIP, firstTime
| WHERE event_count > 10 AND (distinct_icmp_id_count > 5 OR distinct_icmp_seq_count > 5)
| SELECT "GRE/GRETAP Tunnel Scanning" as name, "Reconnaissance" as Tactic, "T1595.002" as Technique, firstTime, SrcIP, targets, event_count, distinct_dest_count, distinct_icmp_id_count, distinct_icmp_seq_count, icmp_ids, icmp_seqs
```

### Unauthorized Internal Access via Tunnels
---
Name: Unauthorized Internal Access via Tunnel Spoofing

Description:

Detects egress network traffic from a private (RFC1918) source IP to a public destination IP. This is a strong indicator of a successful tunnel spoofing attack (e.g., GRE/GRETAP) or a severe network misconfiguration, as private IP addresses should not be routable over the public internet. The attack allows an external actor to bypass perimeter defenses and communicate with internal assets.

Tactic: Initial Access, Command and Control

Technique: T1090.002

Author: RW

Date: 2025-08-13

False Positives: High potential for false positives if not scoped to the correct log sources. This can trigger on misconfigured networks or on logs from internal sensors before Network Address Translation (NAT) is applied. This rule is most effective on perimeter firewall or router logs that inspect egress traffic.

Data Source: Network Session, Firewall Logs

splunk:
```sql
| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Network_Traffic where (All_Traffic.src_ip="10.0.0.0/8" OR All_Traffic.src_ip="172.16.0.0/12" OR All_Traffic.src_ip="192.168.0.0/16") AND NOT (All_Traffic.dest_ip="10.0.0.0/8" OR All_Traffic.dest_ip="172.16.0.0/12" OR All_Traffic.dest_ip="192.168.0.0/16" OR All_Traffic.dest_ip="127.0.0.0/8" OR All_Traffic.dest_ip="169.254.0.0/16" OR All_Traffic.dest_ip="224.0.0.0/4") by All_Traffic.src_ip, All_Traffic.dest_ip, All_Traffic.dest_port, All_Traffic.user
| `drop_dm_object_name("All_Traffic")`
| `security_content_ctime(firstTime)`
| `security_content_ctime(lastTime)`
`comment("The following filter macro can be used to tune the detection by excluding known misconfigurations or specific assets.")`
| `unauthorized_internal_access_via_tunnel_spoofing_filter`
| `eval name="Unauthorized Internal Access via Tunnel Spoofing"`
| `eval Tactic="Initial Access, Command and Control, Defense Evasion"`
| `eval Technique="T1090.002, T1078"`
| table name, Tactic, Technique, firstTime, lastTime, src_ip, dest_ip, dest_port, user, count
```

crowdstrike fql:
```sql
(cidr(src_ip, "10.0.0.0/8") OR cidr(src_ip, "172.16.0.0/12") OR cidr(src_ip, "192.168.0.0/16")) AND NOT (cidr(dest_ip, "10.0.0.0/8") OR cidr(dest_ip, "172.16.0.0/12") OR cidr(dest_ip, "192.168.0.0/16") OR cidr(dest_ip, "127.0.0.0/8") OR cidr(dest_ip, "169.254.0.0/16") OR cidr(dest_ip, "224.0.0.0/4"))
| groupBy([src_ip, dest_ip, dest_port, user])
| count() as count, min(@timestamp) as firstTime, max(@timestamp) as lastTime
| select "Unauthorized Internal Access via Tunnel Spoofing" as name, "Initial Access, Command and Control, Defense Evasion" as Tactic, "T1090.002, T1078" as Technique, firstTime, lastTime, src_ip, dest_ip, dest_port, user, count
```

datadog:
```sql
(CIDR(src_ip, "10.0.0.0/8") OR CIDR(src_ip, "172.16.0.0/12") OR CIDR(src_ip, "192.168.0.0/16")) AND NOT (CIDR(dest_ip, "10.0.0.0/8") OR CIDR(dest_ip, "172.16.0.0/12") OR CIDR(dest_ip, "192.168.0.0/16") OR CIDR(dest_ip, "127.0.0.0/8") OR CIDR(dest_ip, "169.254.0.0/16") OR CIDR(dest_ip, "224.0.0.0/4"))
| stats count, min(@timestamp) as firstTime, max(@timestamp) as lastTime by src_ip, dest_ip, dest_port, user
| select "Unauthorized Internal Access via Tunnel Spoofing" as name, "Initial Access, Command and Control, Defense Evasion" as Tactic, "T1090.002, T1078" as Technique, firstTime, lastTime, src_ip, dest_ip, dest_port, user, count
```

elastic:
```sql
FROM network-traffic*
| WHERE CIDR_MATCH(source.ip, "10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16") AND NOT CIDR_MATCH(destination.ip, "10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "127.0.0.0/8", "169.254.0.0/16", "224.0.0.0/4")
| STATS COUNT() as count, MIN(@timestamp) as firstTime, MAX(@timestamp) as lastTime BY source.ip, destination.ip, destination.port, user.id
| EVAL name = "Unauthorized Internal Access via Tunnel Spoofing", Tactic = "Initial Access, Command and Control, Defense Evasion", Technique = "T1090.002, T1078"
| KEEP name, Tactic, Technique, firstTime, lastTime, source.ip, destination.ip, destination.port, user.id, count
```

sentinel one:
```sql
EventType = "IP Connect" AND (SrcIP ~= "^10." OR SrcIP ~= "^172.(1[6-9]|2[0-9]|3[0-1])." OR SrcIP ~= "^192.168.") AND NOT (DstIP ~= "^10." OR DstIP ~= "^172.(1[6-9]|2[0-9]|3[0-1])." OR DstIP ~= "^192.168." OR DstIP ~= "^127." OR DstIP ~= "^169.254." OR DstIP ~= "^22[4-9]." OR DstIP ~= "^23[0-9]." OR DstIP ~= "^2[4-5][0-9].")
| STATS COUNT() as count, MIN(EventTime) as firstTime, MAX(EventTime) as lastTime BY SrcIP, DstIP, DstPort, User
| SELECT "Unauthorized Internal Access via Tunnel Spoofing" as name, "Initial Access, Command and Control, Defense Evasion" as Tactic, "T1090.002, T1078" as Technique, firstTime, lastTime, SrcIP, DstIP, DstPort, User, count
```
