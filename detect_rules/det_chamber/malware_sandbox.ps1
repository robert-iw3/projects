<#
    detonation_chamber.ps1 - Automated Malware Sandbox Analysis in PowerShell
    Version 2.1

    Supports INetSim, Magnet RESPONSE or Cuckoo Sandbox, YARA, CAPA, pefile, Volatility
    Logs to C:\Logs\malware_sandbox.log, errors.log, yara_compile.log
    Outputs to E:\Collections\<ComputerName>-<Timestamp>

#>

param (
    [string]$MalwsPath = "E:\Malware",
    [string]$MalwdPath = "~\Desktop",
    [string[]]$Malware,
    [int]$PcapTime = 180,
    [string]$ToolsDir = "E:\Tools\Windows",
    [string]$CollectionDir = "E:\Collections",
    [string]$ProcmonConfig = "E:\Tools\Windows\malw.pmc",
    [int]$Parallel = 4,
    [string]$VolatilityPlugins = "windows.pslist,windows.netscan",
    [switch]$SimulateNetwork,
    [string]$EvidenceTool = "magnet",
    [string]$CuckooUrl = "http://cuckoo:8090"
)

# Configure logging
$LogDir = "C:\Logs"
$LogFile = "$LogDir\malware_sandbox.log"
$ErrorLog = "$LogDir\errors.log"
if (-not (Test-Path $LogDir)) { New-Item -ItemType Directory -Path $LogDir -Force | Out-Null }
$LogMessage = { param($Level, $Message) Add-Content -Path $LogFile -Value "$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') [$Level] $Message" }
$ErrorMessage = { param($Level, $Message) Add-Content -Path $ErrorLog -Value "$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') [$Level] $Message" }
& $LogMessage "INFO" "Starting malware_sandbox.ps1"

# Constants
$Version = "2.1"
$YaraRules = "E:\YARA\windows_x64_rules.compiled"
$CYAN = "`e[36m"
$YELLOW = "`e[33m"
$RESET = "`e[0m"

# Check admin privileges
$isAdmin = ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
if (-not $isAdmin) {
    & $ErrorMessage "ERROR" "Admin permissions not detected. Exiting."
    Write-Host "${CYAN}Admin permissions required${RESET}"
    exit 1
}

# Check virtualization
try {
    $reg = Get-Item "HKLM:\SYSTEM\CurrentControlSet\Services"
    $vmware = ($reg.GetSubKeyNames() | Where-Object { $_ -like "*VMware*" }).Count -gt 0
    if (-not $vmware) {
        & $LogMessage "WARNING" "Not running in a virtualized environment"
        Write-Host "${CYAN}Warning: Not running in a virtualized environment${RESET}"
    }
} catch {
    & $ErrorMessage "ERROR" "Error checking virtualization: $_"
}

# Print banner
$banner = @"
                 .
                 .
                 .       :
                 :      .
        :..   :  : :  .
           ..  ; :: .
              ... .. :..
             ::: :...
         ::.:.:...;; .....
      :..     .;.. :;     ..
            . :. .  ;.
             .: ;;: ;.
            :; .BRRRV;
               YB BMMMBR
              ;BVIMMMMMt
        .=YRBBBMMMMMMMB
      =RMMMMMMMMMMMMMM;
    ;BMMR=VMMMMMMMMMMMV.
   tMMR::VMMMMMMMMMMMMMB:
  tMMt ;BMMMMMMMMMMMMMMMB.
 ;MMY ;MMMMMMMMMMMMMMMMMMV
 XMB .BMMMMMMMMMMMMMMMMMMM:
 BMI +MMMMMMMMMMMMMMMMMMMMi
.MM= XMMMMMMMMMMMMMMMMMMMMY
 BMt YMMMMMMMMMMMMMMMMMMMMi
 VMB +MMMMMMMMMMMMMMMMMMMM:
 ;MM+ BMMMMMMMMMMMMMMMMMMR
  tMBVBMMMMMMMMMMMMMMMMMB.
   tMMMMMMMMMMMMMMMMMMMB:
    ;BMMMMMMMMMMMMMMMMY
      +BMMMMMMMMMMMBY:
        :+YRBBBRVt; detonation_chamber.ps1
"@
& $LogMessage "INFO" $banner
Write-Host "${CYAN}$banner`nCapture. Detonate. Collect.`nversion $Version | @rw | Â©${RESET}"

# Create directory
function Create-Directory($Path) {
    try {
        New-Item -ItemType Directory -Path $Path -Force | Out-Null
        & $LogMessage "INFO" "Created directory: $Path"
        return $true
    } catch {
        & $ErrorMessage "ERROR" "Error creating directory $Path: $_"
        return $false
    }
}

# Get host IP
function Get-HostIP {
    try {
        $nics = Get-NetAdapter | Where-Object { $_.Status -eq "Up" -and $_.Name -notlike "*Loopback*" }
        foreach ($nic in $nics) {
            $ip = (Get-NetIPAddress -InterfaceAlias $nic.Name -AddressFamily IPv4).IPAddress
            if ($ip -and $ip -ne "127.0.0.1") {
                & $LogMessage "INFO" "Found IP address: $ip"
                return $ip
            }
        }
        & $LogMessage "WARNING" "No valid IPv4 address found"
        return $null
    } catch {
        & $ErrorMessage "ERROR" "Error retrieving IP address: $_"
        return $null
    }
}

# Simulate network with INetSim
function Simulate-Network($CollectionPath, $CollectionId) {
    & $LogMessage "INFO" "Simulating network traffic for $CollectionId with INetSim"
    try {
        $inetsimExe = "$ToolsDir\inetsim\inetsim.exe"
        $inetsimConf = "$ToolsDir\inetsim\inetsim.conf"
        $simLog = "$CollectionPath\$CollectionId-inetsim.log"
        if (-not (Test-Path $inetsimExe) -or -not (Test-Path $inetsimConf)) {
            & $ErrorMessage "ERROR" "INetSim not found at $inetsimExe or $inetsimConf"
            return @{ "inetsim" = @{ "error" = "INetSim not found" } }
        }
        $process = Start-Process -FilePath $inetsimExe -ArgumentList "--config $inetsimConf --log-dir $CollectionPath --log-prefix $CollectionId-" -PassThru
        & $LogMessage "INFO" "INetSim started for $CollectionId (PID: $($process.Id))"
        Start-Sleep -Seconds 5
        return @{ "inetsim" = @{ "pid" = $process.Id; "log" = $simLog } }
    } catch {
        & $ErrorMessage "ERROR" "Error starting INetSim for $CollectionId: $_"
        return @{ "inetsim" = @{ "error" = $_ } }
    }
}

# Terminate INetSim
function Terminate-INetSim($Pid) {
    try {
        Stop-Process -Id $Pid -Force -ErrorAction Stop
        & $LogMessage "INFO" "Terminated INetSim (PID: $Pid)"
    } catch {
        & $ErrorMessage "WARNING" "INetSim process $Pid not found or error: $_"
    }
}

# Wait countdown
function Wait-Count($Seconds, $Malware) {
    try {
        for ($s = $Seconds; $s -ge 0; $s--) {
            Write-Host "`r${YELLOW}Detonating $Malware - Time left: $s seconds${RESET}" -NoNewline
            Start-Sleep -Seconds 1
        }
        Write-Host ""
    } catch {
        & $ErrorMessage "ERROR" "Error in countdown timer for $Malware: $_"
    }
}

# Terminate process
function Terminate-Process($ProcessName) {
    try {
        $processes = Get-Process | Where-Object { $_.Name -eq $ProcessName -or $_.Path -like "*$ProcessName" }
        foreach ($proc in $processes) {
            Stop-Process -Id $proc.Id -Force -ErrorAction Stop
            & $LogMessage "INFO" "Terminated process $ProcessName (PID: $($proc.Id))"
            return
        }
        & $LogMessage "WARNING" "Process $ProcessName not found"
    } catch {
        & $ErrorMessage "ERROR" "Error terminating process $ProcessName: $_"
    }
}

# Validate paths
function Validate-Paths($MalwsPath, $MalwdPath, $ToolsDir, $ProcmonConfig, $MalwareList) {
    $errors = @()
    foreach ($malware in $MalwareList) {
        if (-not (Test-Path "$MalwsPath\$malware")) {
            $errors += "Malware file not found: $MalwsPath\$malware"
        }
    }
    $paths = @(
        $ToolsDir,
        "$ToolsDir\Procmon.exe",
        "$ToolsDir\etl2pcapng.exe",
        "$ToolsDir\vol.exe",
        "$ToolsDir\capa.exe",
        "$ToolsDir\yara64.exe",
        $ProcmonConfig,
        $YaraRules
    )
    if ($EvidenceTool -eq "magnet" -and -not (Test-Path "$ToolsDir\MagnetRESPONSE.exe")) {
        $errors += "Magnet RESPONSE not found: $ToolsDir\MagnetRESPONSE.exe"
    }
    if ($SimulateNetwork -and -not (Test-Path "$ToolsDir\inetsim\inetsim.exe")) {
        $errors += "INetSim not found: $ToolsDir\inetsim\inetsim.exe"
    }
    foreach ($path in $paths) {
        if (-not (Test-Path $path)) {
            $errors += "Path not found: $path"
        }
    }
    if ($errors) {
        foreach ($error in $errors) {
            & $ErrorMessage "ERROR" $error
            Write-Host "${CYAN}$error${RESET}"
        }
        exit 1
    }
}

# Run pefile analysis
function Run-Pefile($MalwarePath, $CollectionPath, $Collection, $Malproc) {
    $result = @{ "file" = $MalwarePath; "pefile" = @{} }
    & $LogMessage "INFO" "Running pefile analysis on $MalwarePath"
    try {
        $pe = New-Object -TypeName pefile.PE -ArgumentList $MalwarePath
        $result["pefile"] = @{
            "imphash" = $pe.Imphash
            "sections" = $pe.sections | ForEach-Object { $_.Name.Trim([char]0) }
            "imports" = if ($pe.DIRECTORY_ENTRY_IMPORT) {
                $pe.DIRECTORY_ENTRY_IMPORT | ForEach-Object {
                    @{ "dll" = $_.dll; "imports" = $_.imports | ForEach-Object { $_.name } }
                }
            } else { @() }
        }
        & $LogMessage "INFO" "pefile analysis completed for $MalwarePath"
    } catch {
        & $ErrorMessage "ERROR" "pefile error for $MalwarePath: $_"
        $result["pefile"]["error"] = $_
    }
    return $result
}

# Run CAPA analysis
function Run-Capa($ToolsDir, $MalwarePath, $CollectionPath, $Collection, $Malproc) {
    $result = @{ "file" = $MalwarePath; "capa" = @{} }
    & $LogMessage "INFO" "Running CAPA analysis on $MalwarePath"
    try {
        $capaExe = "$ToolsDir\capa.exe"
        $capaOutput = "$CollectionPath\$Collection-$Malproc-capa.json"
        $process = Start-Process -FilePath $capaExe -ArgumentList "`"$MalwarePath`" -f auto -o `"$capaOutput`"" -Wait -PassThru -NoNewWindow
        & $LogMessage "INFO" "CAPA analysis completed for $MalwarePath (Exit Code: $($process.ExitCode))"
        if (Test-Path $capaOutput) {
            $result["capa"] = Get-Content $capaOutput | ConvertFrom-Json
        }
    } catch {
        & $ErrorMessage "ERROR" "Error running CAPA for $MalwarePath: $_"
        $result["capa"]["error"] = $_
    }
    return $result
}

# Run YARA analysis
function Run-Yara($ToolsDir, $MalwarePath, $CollectionPath, $Collection, $Malproc, $YaraRules) {
    $result = @{ "file" = $MalwarePath; "yara" = @{} }
    & $LogMessage "INFO" "Running YARA analysis on $MalwarePath"
    try {
        $yaraExe = "$ToolsDir\yara64.exe"
        $yaraOutput = "$CollectionPath\$Collection-$Malproc-yara.txt"
        $process = Start-Process -FilePath $yaraExe -ArgumentList "`"$YaraRules`" `"$MalwarePath`" -p 4 -t 60 > `"$yaraOutput`"" -Wait -PassThru -NoNewWindow
        & $LogMessage "INFO" "YARA analysis completed for $MalwarePath (Exit Code: $($process.ExitCode))"
        $matches = Get-Content $yaraOutput | Select-String "0x" | ForEach-Object { $_.Line }
        $result["yara"]["matches"] = $matches
    } catch {
        & $ErrorMessage "ERROR" "Error running YARA for $MalwarePath: $_"
        $result["yara"]["error"] = $_
    }
    return $result
}

# Run Magnet RESPONSE
function Run-MagnetResponse($ToolsDir, $CollectionPath, $CollectionId, $Malware) {
    $result = @{ "file" = $Malware; "magnet_response" = @{} }
    & $LogMessage "INFO" "Initiating Magnet RESPONSE for $Malware"
    try {
        $magnetExe = "$ToolsDir\MagnetRESPONSE.exe"
        $magnetCmd = "/accepteula /unattended /output:`"$CollectionPath`" /caseref:$CollectionId /captureram /capturepagefile /capturevolatile /capturesystemfiles /captureextendedprocessinfo /saveprocfiles"
        $process = Start-Process -FilePath $magnetExe -ArgumentList $magnetCmd -Wait -PassThru -NoNewWindow
        & $LogMessage "INFO" "Magnet RESPONSE completed for $Malware (Exit Code: $($process.ExitCode))"
        $result["magnet_response"] = @{ "output" = "$CollectionPath\$CollectionId-MemoryDump.bin"; "exit_code" = $process.ExitCode }
    } catch {
        & $ErrorMessage "ERROR" "Error running Magnet RESPONSE for $Malware: $_"
        $result["magnet_response"]["error"] = $_
    }
    return $result
}

# Run Cuckoo Sandbox
function Run-Cuckoo($MalwarePath, $CollectionPath, $CollectionId, $Malware, $CuckooUrl) {
    $result = @{ "file" = $Malware; "cuckoo" = @{} }
    & $LogMessage "INFO" "Submitting $Malware to Cuckoo Sandbox"
    try {
        $response = Invoke-WebRequest -Uri "$CuckooUrl/tasks/create/file" -Method Post -InFile $MalwarePath -ContentType "multipart/form-data"
        $taskId = ($response.Content | ConvertFrom-Json).task_id
        if (-not $taskId) { throw "No task ID returned from Cuckoo" }
        & $LogMessage "INFO" "Cuckoo task created for $Malware (Task ID: $taskId)"
        for ($i = 0; $i -lt 60; $i++) {
            $report = Invoke-WebRequest -Uri "$CuckooUrl/tasks/report/$taskId/json" -Method Get -ErrorAction SilentlyContinue
            if ($report.StatusCode -eq 200) {
                $cuckooOutput = "$CollectionPath\$CollectionId-cuckoo.json"
                $report.Content | Out-File $cuckooOutput
                & $LogMessage "INFO" "Cuckoo analysis completed for $Malware"
                $result["cuckoo"] = @{ "output" = $cuckooOutput; "task_id" = $taskId }
                return $result
            }
            Start-Sleep -Seconds 5
        }
        & $ErrorMessage "ERROR" "Cuckoo analysis timed out for $Malware after 300 seconds"
        $result["cuckoo"]["error"] = "Timeout"
    } catch {
        & $ErrorMessage "ERROR" "Error submitting to Cuckoo for $Malware: $_"
        $result["cuckoo"]["error"] = $_
    }
    return $result
}

# Analyze memory with Volatility
function Analyze-Memory($ToolsDir, $CollectionPath, $Collection, $Plugins) {
    $result = @{ "file" = $Collection; "volatility" = @{} }
    & $LogMessage "INFO" "Analyzing memory with Volatility"
    try {
        $memoryDump = "$CollectionPath\$Collection-MemoryDump.bin"
        if (-not (Test-Path $memoryDump)) {
            & $ErrorMessage "ERROR" "Memory dump not found: $memoryDump"
            $result["volatility"]["error"] = "Memory dump not found: $memoryDump"
            return $result
        }
        $volExe = "$ToolsDir\vol.exe"
        foreach ($plugin in $Plugins) {
            $volOutput = "$CollectionPath\$Collection-volatility-$($plugin.Replace('.', '-')).txt"
            $process = Start-Process -FilePath $volExe -ArgumentList "-f `"$memoryDump`" $plugin --output-file `"$volOutput`"" -Wait -PassThru -NoNewWindow
            & $LogMessage "INFO" "Volatility plugin $plugin completed (Exit Code: $($process.ExitCode))"
            $result["volatility"][$plugin] = @{ "output" = $volOutput; "exit_code" = $process.ExitCode }
        }
    } catch {
        & $ErrorMessage "ERROR" "Error running Volatility: $_"
        $result["volatility"]["error"] = $_
    }
    return $result
}

# Detonate malware
function Detonate-Malware($Malware, $MalwsPath, $MalwdPath, $ToolsDir, $CollectionPath, $Collection, $ProcmonConfig, $YaraRules, $EvidenceTool, $CuckooUrl) {
    $result = @{ "file" = $Malware; "status" = "success"; "errors" = @() }
    $malwarePath = "$MalwsPath\$Malware"
    $malwareDest = "$MalwdPath\$Malware"
    $malproc = [System.IO.Path]::GetFileNameWithoutExtension($Malware)
    $collectionId = "$Collection-$malproc"

    # Copy malware
    try {
        Copy-Item -Path $malwarePath -Destination $malwareDest -Force
        & $LogMessage "INFO" "Copied $malwarePath to $malwareDest"
    } catch {
        & $ErrorMessage "ERROR" "Error copying $Malware: $_"
        $result["status"] = "failed"
        $result["errors"] += "Copy failed: $_"
        return $result
    }

    # Run pefile
    $result += (Run-Pefile $malwarePath $CollectionPath $Collection $malproc)

    # Run CAPA
    $result += (Run-Capa $ToolsDir $malwarePath $CollectionPath $Collection $malproc)

    # Run YARA
    $result += (Run-Yara $ToolsDir $malwarePath $CollectionPath $Collection $malproc $YaraRules)

    # Process Monitor
    & $LogMessage "INFO" "Initiating Process Monitor for $Malware"
    try {
        $procmonExe = "$ToolsDir\Procmon.exe"
        $procmonCmd = "/accepteula /quiet /loadconfig `"$ProcmonConfig`" /backingfile `"$CollectionPath\$collectionId.pml`""
        $process = Start-Process -FilePath $procmonExe -ArgumentList $procmonCmd -Wait -PassThru -NoNewWindow
        & $LogMessage "INFO" "Process Monitor started for $Malware (Exit Code: $($process.ExitCode))"
    } catch {
        & $ErrorMessage "ERROR" "Error starting Process Monitor for $Malware: $_"
        $result["errors"] += "Process Monitor failed: $_"
    }

    # Network simulation
    $inetsimPid = $null
    if ($SimulateNetwork) {
        $inetsimResult = Simulate-Network $CollectionPath $collectionId
        $result += $inetsimResult
        $inetsimPid = $inetsimResult["inetsim"]["pid"]
    }

    # Detonate malware
    & $LogMessage "INFO" "Detonating $Malware"
    try {
        $malwareProcess = Start-Process -FilePath $malwareDest -PassThru
        & $LogMessage "INFO" "$Malware detonated (PID: $($malwareProcess.Id))"
    } catch {
        & $ErrorMessage "ERROR" "Error detonating $Malware: $_"
        $result["errors"] += "Detonation failed: $_"
    }

    # Wait for capture duration
    Wait-Count $PcapTime $Malware

    # Terminate Process Monitor
    & $LogMessage "INFO" "Terminating Process Monitor for $Malware"
    try {
        $process = Start-Process -FilePath $procmonExe -ArgumentList "/Terminate" -Wait -PassThru -NoNewWindow
        & $LogMessage "INFO" "Process Monitor terminated for $Malware (Exit Code: $($process.ExitCode))"
    } catch {
        & $ErrorMessage "ERROR" "Error terminating Process Monitor for $Malware: $_"
        $result["errors"] += "Process Monitor termination failed: $_"
    }

    # Terminate INetSim
    if ($SimulateNetwork -and $inetsimPid) {
        & $LogMessage "INFO" "Terminating INetSim for $Malware"
        Terminate-INetSim $inetsimPid
    }

    # Evidence collection
    if ($EvidenceTool -eq "magnet") {
        $result += (Run-MagnetResponse $ToolsDir $CollectionPath $collectionId $Malware)
    } else {
        $result += (Run-Cuckoo $malwarePath $CollectionPath $collectionId $Malware $CuckooUrl)
    }

    # Analyze memory
    $result += (Analyze-Memory $ToolsDir $CollectionPath $collectionId $VolatilityPlugins.Split(","))

    # Terminate malware
    & $LogMessage "INFO" "Terminating $Malware"
    Terminate-Process $Malware

    # Convert Process Monitor .pml to .csv
    & $LogMessage "INFO" "Converting Process Monitor PML to CSV for $Malware"
    try {
        $procmonCsvCmd = "/openlog `"$CollectionPath\$collectionId.pml`" /SaveApplyFilter /SaveAs `"$CollectionPath\$collectionId.csv`""
        $process = Start-Process -FilePath $procmonExe -ArgumentList $procmonCsvCmd -Wait -PassThru -NoNewWindow
        & $LogMessage "INFO" "PML converted to CSV for $Malware (Exit Code: $($process.ExitCode))"
        Remove-Item "$CollectionPath\$collectionId.pml" -Force -ErrorAction SilentlyContinue
        & $LogMessage "INFO" "Cleaned up $collectionId.pml"
    } catch {
        & $ErrorMessage "ERROR" "Error converting PML to CSV for $Malware: $_"
        $result["errors"] += "PML to CSV conversion failed: $_"
    }

    if ($result["errors"]) { $result["status"] = "failed" }
    return $result
}

# Aggregate reports
function Aggregate-Reports($Results, $CollectionPath, $Collection) {
    $summary = @{ "timestamp" = (Get-Date -Format "yyyy-MM-dd HH:mm:ss"); "files" = $Results }
    try {
        $summary | ConvertTo-Json -Depth 10 | Out-File "$CollectionPath\$Collection-summary.json"
        & $LogMessage "INFO" "Generated summary report: $CollectionPath\$Collection-summary.json"
    } catch {
        & $ErrorMessage "ERROR" "Error generating summary report: $_"
    }
}

# Main execution
try {
    # Compile YARA rules
    & $LogMessage "INFO" "Compiling YARA rules"
    $compileProcess = Start-Process -FilePath "python" -ArgumentList "E:\app\compile_yara_rules.py --source-dir E:\YARA\Rules --output-file E:\YARA\windows_x64_rules.yar --ps-script E:\app\filter_yara_rules.ps1" -Wait -PassThru -NoNewWindow
    if ($compileProcess.ExitCode -ne 0) {
        & $ErrorMessage "ERROR" "Error compiling YARA rules"
        exit 1
    }

    # Resolve paths
    $MalwsPath = Resolve-Path $MalwsPath -ErrorAction Stop
    $MalwdPath = Resolve-Path $MalwdPath -ErrorAction Stop
    $ToolsDir = Resolve-Path $ToolsDir -ErrorAction Stop
    $CollectionDir = Resolve-Path $CollectionDir -ErrorAction Stop
    $ProcmonConfig = Resolve-Path $ProcmonConfig -ErrorAction Stop

    # Collect malware files
    $malwareList = $Malware
    if (-not $malwareList) {
        $malwareList = Get-ChildItem $MalwsPath | Where-Object { -not $_.PSIsContainer } | ForEach-Object { $_.Name }
    }
    if (-not $malwareList) {
        & $ErrorMessage "ERROR" "No malware files found in $MalwsPath"
        Write-Host "${CYAN}No malware files found in $MalwsPath${RESET}"
        exit 1
    }

    # Validate paths
    Validate-Paths $MalwsPath $MalwdPath $ToolsDir $ProcmonConfig $malwareList

    # Create collection directories
    $tstamp = Get-Date -Format "-yyyyMMddHHmm"
    $collection = "$env:COMPUTERNAME$tstamp"
    $collectionPath = "$CollectionDir\$collection"
    if (-not (Create-Directory $CollectionDir) -or -not (Create-Directory $collectionPath)) {
        exit 1
    }
    & $LogMessage "INFO" "Collection directory $collectionPath"

    # Parallel detonation
    $results = @()
    $jobs = @()
    $batchSize = $Parallel
    for ($i = 0; $i -lt $malwareList.Count; $i += $batchSize) {
        $batch = $malwareList[$i..[math]::Min($i + $batchSize - 1, $malwareList.Count - 1)]
        foreach ($malware in $batch) {
            $jobs += Start-Job -ScriptBlock {
                param($m, $mp, $md, $td, $cp, $c, $pc, $yr, $et, $cu)
                . $using:PSScriptRoot\malware_sandbox.ps1
                Detonate-Malware -Malware $m -MalwsPath $mp -MalwdPath $md -ToolsDir $td -CollectionPath $cp -Collection $c -ProcmonConfig $pc -YaraRules $yr -EvidenceTool $et -CuckooUrl $cu
            } -ArgumentList $malware, $MalwsPath, $MalwdPath, $ToolsDir, $collectionPath, $collection, $ProcmonConfig, $YaraRules, $EvidenceTool, $CuckooUrl
        }
        $jobs | Wait-Job | ForEach-Object {
            $results += Receive-Job $_
            Remove-Job $_
        }
    }

    # Aggregate reports
    Aggregate-Reports $results $collectionPath $collection

    # List collection directory
    & $LogMessage "INFO" "Collection directory contents:"
    Get-ChildItem $collectionPath | ForEach-Object { & $LogMessage "INFO" $_.Name }
    & $LogMessage "INFO" "** End of automation **"
    Write-Host "${YELLOW}** End of automation **${RESET}"
} catch {
    & $ErrorMessage "ERROR" "Main execution failed: $_"
    Write-Host "${CYAN}Main execution failed: $_${RESET}"
    exit 1
}