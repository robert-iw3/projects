import os
import argparse
import logging
import logging.handlers
import subprocess
import shutil
import time
import psutil
import pefile
import json
import requests
from datetime import datetime
from concurrent.futures import ProcessPoolExecutor
import sys
import win32api
import win32con

VERSION = "2.1"

# Configure logging
LOG_DIR = "C:\\Logs"
if not os.path.exists(LOG_DIR):
    os.makedirs(LOG_DIR)
logger = logging.getLogger('malware_sandbox')
logger.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s [%(levelname)s] %(message)s')
file_handler = logging.handlers.RotatingFileHandler(
    os.path.join(LOG_DIR, 'malware_sandbox.log'),
    maxBytes=10*1024*1024,  # 10MB
    backupCount=5
)
file_handler.setFormatter(formatter)
logger.addHandler(file_handler)
error_handler = logging.handlers.RotatingFileHandler(
    os.path.join(LOG_DIR, 'errors.log'),
    maxBytes=10*1024*1024,
    backupCount=5
)
error_handler.setLevel(logging.ERROR)
error_handler.setFormatter(formatter)
logger.addHandler(error_handler)

def print_banner():
    banner = """
                 .
                 .
                 .       :
                 :      .
        :..   :  : :  .
           ..  ; :: .
              ... .. :..
             ::: :...
         ::.:.:...;; .....
      :..     .;.. :;     ..
            . :. .  ;.
             .: ;;: ;.
            :; .BRRRV;
               YB BMMMBR
              ;BVIMMMMMt
        .=YRBBBMMMMMMMB
      =RMMMMMMMMMMMMMM;
    ;BMMR=VMMMMMMMMMMMV.
   tMMR::VMMMMMMMMMMMMMB:
  tMMt ;BMMMMMMMMMMMMMMMB.
 ;MMY ;MMMMMMMMMMMMMMMMMMV
 XMB .BMMMMMMMMMMMMMMMMMMM:
 BMI +MMMMMMMMMMMMMMMMMMMMi
.MM= XMMMMMMMMMMMMMMMMMMMMY
 BMt YMMMMMMMMMMMMMMMMMMMMi
 VMB +MMMMMMMMMMMMMMMMMMMM:
 ;MM+ BMMMMMMMMMMMMMMMMMMR
  tMBVBMMMMMMMMMMMMMMMMMB.
   tMMMMMMMMMMMMMMMMMMMB:
    ;BMMMMMMMMMMMMMMMMY
      +BMMMMMMMMMMMBY:
        :+YRBBBRVt;  detonation_chamber.py
"""
    logger.info(banner)
    print(f"\033[36m{banner}\nCapture. Detonate. Collect.\nversion {VERSION} | @rw | Â©\033[0m")

def check_admin():
    try:
        import ctypes
        is_admin = ctypes.windll.shell32.IsUserAnAdmin() != 0
        if not is_admin:
            logger.error("Admin permissions not detected. Exiting.")
            print("\033[36mAdmin permissions required\033[0m")
            sys.exit(1)
    except Exception as e:
        logger.error(f"Error checking admin permissions: {e}")
        sys.exit(1)

def check_virtualization():
    try:
        key = win32api.RegOpenKey(win32con.HKEY_LOCAL_MACHINE, "SYSTEM\\CurrentControlSet\\Services", 0, win32con.KEY_READ)
        subkeys = [win32api.RegEnumKey(key, i) for i in range(win32api.RegQueryInfoKey(key)[0])]
        vmware = any("VMware" in subkey for subkey in subkeys)
        win32api.RegCloseKey(key)
        if not vmware:
            logger.warning("Not running in a virtualized environment")
            print("\033[36mWarning: Not running in a virtualized environment\033[0m")
    except Exception as e:
        logger.error(f"Error checking virtualization: {e}")

def get_host_ip():
    try:
        for interface in psutil.net_if_addrs().values():
            for addr in interface:
                if addr.family == 2 and addr.address != "127.0.0.1":  # IPv4
                    logger.info(f"Found IP address: {addr.address}")
                    return addr.address
        logger.warning("No valid IPv4 address found")
        return None
    except Exception as e:
        logger.error(f"Error retrieving IP address: {e}")
        return None

def simulate_network(collection_path, collection_id):
    logger.info(f"Simulating network traffic for {collection_id} with INetSim")
    try:
        inetsim_exe = os.path.join(TOOLS_DIR, "inetsim", "inetsim.exe")
        inetsim_conf = os.path.join(TOOLS_DIR, "inetsim", "inetsim.conf")
        sim_log = os.path.join(collection_path, f"{collection_id}-inetsim.log")
        if not os.path.exists(inetsim_exe) or not os.path.exists(inetsim_conf):
            logger.error(f"INetSim not found at {inetsim_exe} or {inetsim_conf}")
            return {"inetsim": {"error": "INetSim not found"}}
        process = subprocess.Popen(
            [inetsim_exe, "--config", inetsim_conf, "--log-dir", collection_path, "--log-prefix", f"{collection_id}-"],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE
        )
        logger.info(f"INetSim started for {collection_id} (PID: {process.pid})")
        time.sleep(5)
        return {"inetsim": {"pid": process.pid, "log": sim_log}}
    except Exception as e:
        logger.error(f"Error starting INetSim for {collection_id}: {e}")
        return {"inetsim": {"error": str(e)}}

def terminate_inetsim(pid):
    try:
        process = psutil.Process(pid)
        process.terminate()
        process.wait(timeout=5)
        logger.info(f"Terminated INetSim (PID: {pid})")
    except psutil.NoSuchProcess:
        logger.warning(f"INetSim process {pid} not found")
    except Exception as e:
        logger.error(f"Error terminating INetSim: {e}")

def wait_count(seconds, malware):
    try:
        for s in range(seconds, -1, -1):
            print(f"\r\033[33mDetonating {malware} - Time left: {s} seconds\033[0m", end="")
            time.sleep(1)
        print("")
    except Exception as e:
        logger.error(f"Error in countdown timer for {malware}: {e}")

def terminate_process(process_name):
    try:
        for proc in psutil.process_iter(['name', 'exe']):
            if proc.info['name'] == process_name or (proc.info['exe'] and process_name in proc.info['exe']):
                proc.terminate()
                proc.wait(timeout=5)
                logger.info(f"Terminated process {process_name} (PID: {proc.pid})")
                return
        logger.warning(f"Process {process_name} not found")
    except Exception as e:
        logger.error(f"Error terminating process {process_name}: {e}")

def validate_paths(malws_path, malwd_path, tools_dir, procmon_config, malware_list):
    errors = []
    for malware in malware_list:
        if not os.path.exists(os.path.join(malws_path, malware)):
            errors.append(f"Malware file not found: {os.path.join(malws_path, malware)}")
    paths = [
        tools_dir,
        os.path.join(tools_dir, "Procmon.exe"),
        os.path.join(tools_dir, "etl2pcapng.exe"),
        os.path.join(tools_dir, "vol.exe"),
        os.path.join(tools_dir, "capa.exe"),
        os.path.join(tools_dir, "yara64.exe"),
        procmon_config,
        YARA_RULES
    ]
    if EVIDENCE_TOOL == "magnet" and not os.path.exists(os.path.join(tools_dir, "MagnetRESPONSE.exe")):
        errors.append(f"Magnet RESPONSE not found: {os.path.join(tools_dir, 'MagnetRESPONSE.exe')}")
    if SIMULATE_NETWORK and not os.path.exists(os.path.join(tools_dir, "inetsim", "inetsim.exe")):
        errors.append(f"INetSim not found: {os.path.join(tools_dir, 'inetsim', 'inetsim.exe')}")
    for path in paths:
        if not os.path.exists(path):
            errors.append(f"Path not found: {path}")
    if errors:
        for error in errors:
            logger.error(error)
            print(f"\033[36m{error}\033[0m")
        sys.exit(1)

def run_pefile(malware_path, collection_path, collection, malproc):
    result = {"file": malware_path, "pefile": {}}
    logger.info(f"Running pefile analysis on {malware_path}")
    try:
        pe = pefile.PE(malware_path)
        result["pefile"] = {
            "imphash": pe.get_imphash(),
            "sections": [section.Name.decode().strip('\x00') for section in pe.sections],
            "imports": [
                {"dll": entry.dll.decode(), "imports": [imp.name.decode() for imp in entry.imports if imp.name]}
                for entry in pe.DIRECTORY_ENTRY_IMPORT
            ] if hasattr(pe, "DIRECTORY_ENTRY_IMPORT") else []
        }
        logger.info(f"pefile analysis completed for {malware_path}")
    except Exception as e:
        logger.error(f"pefile error for {malware_path}: {e}")
        result["pefile"]["error"] = str(e)
    return result

def run_capa(tools_dir, malware_path, collection_path, collection, malproc):
    result = {"file": malware_path, "capa": {}}
    logger.info(f"Running CAPA analysis on {malware_path}")
    try:
        capa_exe = os.path.join(tools_dir, "capa.exe")
        capa_output = os.path.join(collection_path, f"{collection}-{malproc}-capa.json")
        process = subprocess.run([capa_exe, malware_path, "-f", "auto", "-o", capa_output], capture_output=True, text=True, timeout=300)
        logger.info(f"CAPA analysis completed for {malware_path} (Exit Code: {process.returncode})")
        if os.path.exists(capa_output):
            with open(capa_output, 'r') as f:
                result["capa"] = json.load(f)
    except subprocess.TimeoutExpired:
        logger.error(f"CAPA timed out for {malware_path}")
        result["capa"]["error"] = "Timeout"
    except Exception as e:
        logger.error(f"Error running CAPA for {malware_path}: {e}")
        result["capa"]["error"] = str(e)
    return result

def run_yara(tools_dir, malware_path, collection_path, collection, malproc, yara_rules):
    result = {"file": malware_path, "yara": {}}
    logger.info(f"Running YARA analysis on {malware_path}")
    try:
        yara_exe = os.path.join(tools_dir, "yara64.exe")
        yara_output = os.path.join(collection_path, f"{collection}-{malproc}-yara.txt")
        process = subprocess.run([yara_exe, yara_rules, malware_path, "-p", "4", "-t", "60"], capture_output=True, text=True, timeout=300)
        with open(yara_output, 'w') as f:
            f.write(process.stdout)
        matches = [line for line in process.stdout.splitlines() if "0x" in line]
        result["yara"]["matches"] = matches
        logger.info(f"YARA analysis completed for {malware_path} (Exit Code: {process.returncode})")
    except subprocess.TimeoutExpired:
        logger.error(f"YARA timed out for {malware_path}")
        result["yara"]["error"] = "Timeout"
    except Exception as e:
        logger.error(f"Error running YARA for {malware_path}: {e}")
        result["yara"]["error"] = str(e)
    return result

def run_magnet_response(tools_dir, collection_path, collection_id, malware):
    result = {"file": malware, "magnet_response": {}}
    logger.info(f"Initiating Magnet RESPONSE for {malware}")
    try:
        magnet_exe = os.path.join(tools_dir, "MagnetRESPONSE.exe")
        magnet_cmd = [
            magnet_exe, "/accepteula", "/unattended", f"/output:{collection_path}",
            f"/caseref:{collection_id}", "/captureram", "/capturepagefile",
            "/capturevolatile", "/capturesystemfiles", "/captureextendedprocessinfo",
            "/saveprocfiles"
        ]
        process = subprocess.run(magnet_cmd, capture_output=True, text=True, timeout=600)
        logger.info(f"Magnet RESPONSE completed for {malware} (Exit Code: {process.returncode})")
        result["magnet_response"] = {
            "output": os.path.join(collection_path, f"{collection_id}-MemoryDump.bin"),
            "exit_code": process.returncode
        }
    except subprocess.TimeoutExpired:
        logger.error(f"Magnet RESPONSE timed out for {malware}")
        result["magnet_response"]["error"] = "Timeout"
    except Exception as e:
        logger.error(f"Error running Magnet RESPONSE for {malware}: {e}")
        result["magnet_response"]["error"] = str(e)
    return result

def run_cuckoo(malware_path, collection_path, collection_id, malware, cuckoo_url):
    result = {"file": malware, "cuckoo": {}}
    logger.info(f"Submitting {malware} to Cuckoo Sandbox")
    try:
        with open(malware_path, 'rb') as f:
            response = requests.post(f"{cuckoo_url}/tasks/create/file", files={"file": f})
        task_id = response.json().get("task_id")
        if not task_id:
            raise ValueError("No task ID returned from Cuckoo")
        logger.info(f"Cuckoo task created for {malware} (Task ID: {task_id})")
        for _ in range(60):  # Wait up to 5 minutes
            response = requests.get(f"{cuckoo_url}/tasks/report/{task_id}/json")
            if response.status_code == 200:
                cuckoo_output = os.path.join(collection_path, f"{collection_id}-cuckoo.json")
                with open(cuckoo_output, 'w') as f:
                    f.write(response.text)
                logger.info(f"Cuckoo analysis completed for {malware}")
                result["cuckoo"] = {"output": cuckoo_output, "task_id": task_id}
                return result
            time.sleep(5)
        logger.error(f"Cuckoo analysis timed out for {malware} after 300 seconds")
        result["cuckoo"]["error"] = "Timeout"
    except Exception as e:
        logger.error(f"Error submitting to Cuckoo for {malware}: {e}")
        result["cuckoo"]["error"] = str(e)
    return result

def analyze_memory(tools_dir, collection_path, collection, plugins):
    result = {"file": collection, "volatility": {}}
    logger.info("Analyzing memory with Volatility")
    try:
        memory_dump = os.path.join(collection_path, f"{collection}-MemoryDump.bin")
        if not os.path.exists(memory_dump):
            logger.error(f"Memory dump not found: {memory_dump}")
            result["volatility"]["error"] = f"Memory dump not found: {memory_dump}"
            return result
        vol_exe = os.path.join(tools_dir, "vol.exe")
        for plugin in plugins:
            vol_output = os.path.join(collection_path, f"{collection}-volatility-{plugin.replace('.', '-')}.txt")
            process = subprocess.run([vol_exe, "-f", memory_dump, plugin, "--output-file", vol_output],
                                    capture_output=True, text=True, timeout=600)
            logger.info(f"Volatility plugin {plugin} completed (Exit Code: {process.returncode})")
            result["volatility"][plugin] = {"output": vol_output, "exit_code": process.returncode}
    except subprocess.TimeoutExpired:
        logger.error("Volatility analysis timed out")
        result["volatility"]["error"] = "Timeout"
    except Exception as e:
        logger.error(f"Error running Volatility: {e}")
        result["volatility"]["error"] = str(e)
    return result

def detonate_malware(malware, malws_path, malwd_path, tools_dir, collection_path, collection, procmon_config, yara_rules, evidence_tool, cuckoo_url):
    result = {"file": malware, "status": "success", "errors": []}
    malware_path = os.path.join(malws_path, malware)
    malware_dest = os.path.join(malwd_path, malware)
    malproc = os.path.splitext(malware)[0]
    collection_id = f"{collection}-{malproc}"

    # Copy malware
    try:
        shutil.copy(malware_path, malware_dest)
        logger.info(f"Copied {malware_path} to {malware_dest}")
    except Exception as e:
        logger.error(f"Error copying {malware}: {e}")
        result["status"] = "failed"
        result["errors"].append(f"Copy failed: {e}")
        return result

    # Run pefile
    result.update(run_pefile(malware_path, collection_path, collection, malproc))

    # Run CAPA
    result.update(run_capa(tools_dir, malware_path, collection_path, collection, malproc))

    # Run YARA
    result.update(run_yara(tools_dir, malware_path, collection_path, collection, malproc, yara_rules))

    # Process Monitor
    logger.info(f"Initiating Process Monitor for {malware}")
    try:
        procmon_exe = os.path.join(tools_dir, "Procmon.exe")
        procmon_cmd = [procmon_exe, "/accepteula", "/quiet", "/loadconfig", procmon_config,
                       "/backingfile", os.path.join(collection_path, f"{collection_id}.pml")]
        process = subprocess.Popen(procmon_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        logger.info(f"Process Monitor started for {malware} (PID: {process.pid})")
    except Exception as e:
        logger.error(f"Error starting Process Monitor for {malware}: {e}")
        result["errors"].append(f"Process Monitor failed: {e}")

    # Network simulation
    inetsim_pid = None
    if SIMULATE_NETWORK:
        inetsim_result = simulate_network(collection_path, collection_id)
        result.update(inetsim_result)
        inetsim_pid = inetsim_result["inetsim"].get("pid")

    # Detonate malware
    logger.info(f"Detonating {malware}")
    try:
        process = subprocess.Popen(malware_dest, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        logger.info(f"{malware} detonated (PID: {process.pid})")
    except Exception as e:
        logger.error(f"Error detonating {malware}: {e}")
        result["errors"].append(f"Detonation failed: {e}")

    # Wait for capture duration
    wait_count(PCAP_TIME, malware)

    # Terminate Process Monitor
    logger.info(f"Terminating Process Monitor for {malware}")
    try:
        process = subprocess.run([procmon_exe, "/Terminate"], capture_output=True, text=True, timeout=60)
        logger.info(f"Process Monitor terminated for {malware} (Exit Code: {process.returncode})")
    except Exception as e:
        logger.error(f"Error terminating Process Monitor for {malware}: {e}")
        result["errors"].append(f"Process Monitor termination failed: {e}")

    # Terminate INetSim
    if SIMULATE_NETWORK and inetsim_pid:
        logger.info(f"Terminating INetSim for {malware}")
        terminate_inetsim(inetsim_pid)

    # Evidence collection
    if evidence_tool == "magnet":
        result.update(run_magnet_response(tools_dir, collection_path, collection_id, malware))
    else:
        result.update(run_cuckoo(malware_path, collection_path, collection_id, malware, cuckoo_url))

    # Analyze memory
    result.update(analyze_memory(tools_dir, collection_path, collection_id, VOLATILITY_PLUGINS))

    # Terminate malware
    logger.info(f"Terminating {malware}")
    terminate_process(malware)

    # Convert Process Monitor .pml to .csv
    logger.info(f"Converting Process Monitor PML to CSV for {malware}")
    try:
        procmon_csv_cmd = [procmon_exe, "/openlog", os.path.join(collection_path, f"{collection_id}.pml"),
                          "/SaveApplyFilter", "/SaveAs", os.path.join(collection_path, f"{collection_id}.csv")]
        process = subprocess.run(procmon_csv_cmd, capture_output=True, text=True, timeout=300)
        logger.info(f"PML converted to CSV for {malware} (Exit Code: {process.returncode})")
        os.remove(os.path.join(collection_path, f"{collection_id}.pml"))
        logger.info(f"Cleaned up {collection_id}.pml")
    except Exception as e:
        logger.error(f"Error converting PML to CSV for {malware}: {e}")
        result["errors"].append(f"PML to CSV conversion failed: {e}")

    if result["errors"]:
        result["status"] = "failed"
    return result

def aggregate_reports(results, collection_path, collection):
    summary = {
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "files": results
    }
    try:
        with open(os.path.join(collection_path, f"{collection}-summary.json"), 'w') as f:
            json.dump(summary, f, indent=2)
        logger.info(f"Generated summary report: {os.path.join(collection_path, f'{collection}-summary.json')}")
    except Exception as e:
        logger.error(f"Error generating summary report: {e}")

def main():
    global PCAP_TIME, TOOLS_DIR, SIMULATE_NETWORK, EVIDENCE_TOOL, CUCKOO_URL, VOLATILITY_PLUGINS, YARA_RULES
    parser = argparse.ArgumentParser(description="Automated Malware Sandbox")
    parser.add_argument('--malws-path', default="E:\\Malware", help="Source directory for malware files")
    parser.add_argument('--malwd-path', default="~\\Desktop", help="Destination directory for detonation")
    parser.add_argument('--malware', nargs='+', help="Specific malware files to analyze")
    parser.add_argument('--pcap-time', type=int, default=180, help="Analysis duration per file in seconds")
    parser.add_argument('--tools-dir', default="E:\\Tools\\Windows", help="Directory containing tools")
    parser.add_argument('--collection-dir', default="E:\\Collections", help="Directory for collection outputs")
    parser.add_argument('--procmon-config', default="E:\\Tools\\Windows\\malw.pmc", help="Process Monitor configuration file")
    parser.add_argument('--parallel', type=int, default=4, help="Number of parallel processes")
    parser.add_argument('--volatility-plugins', default="windows.pslist,windows.netscan", help="Comma-separated Volatility plugins")
    parser.add_argument('--simulate-network', action='store_true', help="Simulate network with INetSim")
    parser.add_argument('--evidence-tool', choices=['magnet', 'cuckoo'], default='magnet', help="Evidence collection tool")
    parser.add_argument('--cuckoo-url', default="http://cuckoo:8090", help="Cuckoo Sandbox API URL")
    args = parser.parse_args()

    PCAP_TIME = args.pcap_time
    TOOLS_DIR = os.path.abspath(os.path.expanduser(args.tools_dir))
    SIMULATE_NETWORK = args.simulate_network
    EVIDENCE_TOOL = args.evidence_tool
    CUCKOO_URL = args.cuckoo_url
    VOLATILITY_PLUGINS = args.volatility_plugins.split(",")
    YARA_RULES = "E:\\YARA\\windows_x64_rules.compiled"

    print_banner()
    check_admin()
    check_virtualization()
    host_ip = get_host_ip()

    # Resolve paths
    malws_path = os.path.abspath(os.path.expanduser(args.malws_path))
    malwd_path = os.path.abspath(os.path.expanduser(args.malwd_path))
    collection_dir = os.path.abspath(os.path.expanduser(args.collection_dir))
    procmon_config = os.path.abspath(os.path.expanduser(args.procmon_config))

    # Collect malware files
    malware_list = args.malware
    if not malware_list:
        malware_list = [f for f in os.listdir(malws_path) if os.path.isfile(os.path.join(malws_path, f))]
    if not malware_list:
        logger.error(f"No malware files found in {malws_path}")
        print(f"\033[36mNo malware files found in {malws_path}\033[0m")
        sys.exit(1)

    # Validate paths
    validate_paths(malws_path, malwd_path, TOOLS_DIR, procmon_config, malware_list)

    # Create collection directories
    tstamp = datetime.now().strftime("-%Y%m%d%H%M")
    collection = f"{os.environ['COMPUTERNAME']}{tstamp}"
    collection_path = os.path.join(collection_dir, collection)
    os.makedirs(collection_dir, exist_ok=True)
    os.makedirs(collection_path, exist_ok=True)
    logger.info(f"Collection directory {collection_path}")

    # Parallel detonation
    results = []
    with ProcessPoolExecutor(max_workers=args.parallel) as executor:
        futures = [
            executor.submit(detonate_malware, malware, malws_path, malwd_path, TOOLS_DIR,
                           collection_path, collection, procmon_config, YARA_RULES, EVIDENCE_TOOL, CUCKOO_URL)
            for malware in malware_list
        ]
        for future in futures:
            try:
                results.append(future.result())
            except Exception as e:
                logger.error(f"Error in parallel execution: {e}")
                results.append({"error": str(e)})

    # Aggregate reports
    aggregate_reports(results, collection_path, collection)

    # List collection directory
    logger.info("Collection directory contents:")
    for item in os.listdir(collection_path):
        logger.info(item)
    logger.info("** End of automation **")
    print("\033[33m** End of automation **\033[0m")

if __name__ == "__main__":
    main()