rule MemoryExploitationAndDEPBypass {
  meta:
    name = "Memory Exploitation and DEP Bypass Detection"
    author = "RW"
    date = "2025-08-09"
    description = "Detects memory-based exploits including DEP bypass, ROP chains, and suspicious memory allocations by correlating DEP violations, RWX memory allocations, and unusual sequences of memory API calls."
    mitre_attack = "T1055.001, T1055.009, T1190, T1203"
    severity = "HIGH" // Setting severity to HIGH due to the nature of memory exploitation
    false_positives = "Legitimate applications like JIT compilers, browsers, development tools, or poorly-coded applications may trigger this rule. Tuning allowlists is crucial."

  // --- Configuration ---
  strings:
    // Define thresholds for sequence detection
    $call_threshold = 5 // Minimum API calls in a sequence
    $time_window_ms = 120000 // 2 minutes in milliseconds

  events:
    // Part 1: Direct DEP Violation
    $dep_violation.metadata.event_type = "PROCESS_MEMORY_DEP_VIOLATION" // Assuming UDM mapping for DEP violations
    $dep_violation.security_result.category = "DEP Violation" // Further refining if DEP category is available

    // Part 2 & 3: RWX Memory Allocation (Generic, and specific to Stack/Heap)
    $rwx_allocation.metadata.event_type = "PROCESS_MEMORY_PROTECTION_CHANGE" or $rwx_allocation.metadata.event_type = "PROCESS_MEMORY_ALLOCATION"
    // Exclude known good processes
    not $rwx_allocation.principal.process.file.full_path in %known_good_processes
    // Check for PAGE_EXECUTE_READWRITE (Protection == 64)
    $rwx_allocation.memory.protection = "PAGE_EXECUTE_READWRITE" // Assuming UDM field for memory protection
    // Further tuning: Focus on common targets, if desired (e.g., Office apps, Acrobat Reader)
    // $rwx_allocation.principal.process.file.full_path in %exploitation_targets

    // Part 4: Unusual Sequence of Memory API Calls (ROP Chain pattern)
    $api_call.metadata.event_type = "PROCESS_MEMORY_PROTECTION_CHANGE" or
                                     $api_call.metadata.event_type = "PROCESS_MEMORY_ALLOCATION" or
                                     $api_call.metadata.event_type = "PROCESS_MEMORY_WRITE" // Assuming specific UDM events for these actions
    not $api_call.principal.process.file.full_path in %known_good_processes
    // Check if the allocation/protection change is RWX (PAGE_EXECUTE_READWRITE)
    $api_call.memory.protection = "PAGE_EXECUTE_READWRITE" or not $api_call.memory.protection = "" // We need `memory.protection` for `ProtectVirtualMemory` or `AllocateVirtualMemory` to be 64 for `IsRwx`, but `WriteVirtualMemory` doesn't have it.
                                                                                               // A more robust approach might be to join the writes with prior protection changes.
                                                                                               // For `WriteVirtualMemoryApiCall`, `memory.protection` might not be directly available, it implies writing *to* memory.
                                                                                               // The UDM field for this might vary significantly depending on the log source.

  match:
    // Match DEP violations or RWX allocations (individual detections)
    $dep_violation or $rwx_allocation or

    // Correlate sequence of API calls within a time window for the same process
    // This is the most complex part to emulate directly.
    // We'll count the relevant API calls for a process within a window.
    $api_call.principal.process.product_id, $api_call.principal.asset.asset_id
    group by $api_call.principal.process.product_id, $api_call.principal.asset.asset_id, $api_call.principal.process.file.full_path, $api_call.principal.process.command_line, $api_call.principal.asset.hostname
    window $time_window_ms on $api_call.metadata.event_timestamp

  outcome:
    // Outcome for DEP Violation
    $dep_violation_time = $dep_violation.metadata.event_timestamp
    $dep_violation_device = $dep_violation.principal.asset.hostname
    $dep_violation_process = $dep_violation.principal.process.file.full_path
    $dep_violation_commandline = $dep_violation.principal.process.command_line
    $dep_violation_pid = $dep_violation.principal.process.product_id
    $dep_violation_details = $dep_violation.security_result.summary

    // Outcome for RWX Allocations
    $rwx_allocation_time = $rwx_allocation.metadata.event_timestamp
    $rwx_allocation_device = $rwx_allocation.principal.asset.hostname
    $rwx_allocation_process = $rwx_allocation.principal.process.file.full_path
    $rwx_allocation_commandline = $rwx_allocation.principal.process.command_line
    $rwx_allocation_pid = $rwx_allocation.principal.process.product_id
    $rwx_allocation_details = $rwx_allocation.memory.protection // Will be PAGE_EXECUTE_READWRITE

    // Outcome for Memory API Sequence
    $sequence_start_time = min($api_call.metadata.event_timestamp)
    $sequence_end_time = max($api_call.metadata.event_timestamp)
    $sequence_device = $api_call.principal.asset.hostname
    $sequence_process = $api_call.principal.process.file.full_path
    $sequence_commandline = $api_call.principal.process.command_line
    $sequence_pid = $api_call.principal.process.product_id
    $api_call_count = count($api_call.metadata.event_id)
    $rwx_call_count = count(if($api_call.memory.protection = "PAGE_EXECUTE_READWRITE", $api_call.metadata.event_id))
    $api_call_sequence = array_distinct($api_call.metadata.event_type) limit 10 // Make a list of event types

    $detection_technique = if(
        $dep_violation_pid != "", "DEP Violation",
        if($rwx_allocation_pid != "", "RWX Memory Allocation", "Unusual Memory API Sequence")
    )
    // Categorize specific RWX allocation types if needed
    $rwx_specific_type = if($rwx_allocation.memory.type = "Stack" or $rwx_allocation.memory.type = "Heap", "RWX Memory on Stack/Heap", "")


  condition:
    // Either a DEP violation, an RWX allocation, or a suspicious API sequence
    $dep_violation or $rwx_allocation or ($api_call_count > $call_threshold and $rwx_call_count > 0)
}

// Reference List (to be created in Chronicle):
// 1.  **known_good_processes:** Create a Chronicle Reference List named `known_good_processes` and populate it with:
//     chrome.exe, firefox.exe, msedge.exe, iexplore.exe, powershell.exe, pwsh.exe, csc.exe,
//     cvtres.exe, MSBuild.exe, devenv.exe, javaw.exe, java.exe, node.exe
// 2. (Optional) **exploitation_targets:** Create a Chronicle Reference List named `exploitation_targets` and populate it with common target processes if you want to enable that specific tuning filter.
