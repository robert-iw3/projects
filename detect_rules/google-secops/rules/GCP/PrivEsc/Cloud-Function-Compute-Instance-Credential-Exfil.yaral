rule gcp_credential_exfiltration_via_new_resource {
  meta:
    author = "RW"
    date = "2025-08-20"
    description = "Detects the creation or update of a GCP Cloud Function or the creation of a Compute Engine instance with an attached service account, which could be a precursor to credential exfiltration. Specifically for Compute Instances, this rule looks for a startup script designed to access the metadata service and exfiltrate credentials using common tools like 'curl' or 'wget'. An attacker with permissions like 'cloudfunctions.functions.create' or 'compute.instances.create', along with 'iam.serviceAccounts.actAs', can abuse these features to execute code as a privileged service account and steal its credentials."
    false_positives = "Legitimate infrastructure-as-code (e.g., Terraform) or CI/CD pipelines creating resources with attached service accounts. The Cloud Function detection is broad and may require tuning by filtering for known principals or projects. The Compute Instance detection is more specific but could still trigger on legitimate startup scripts that use curl/wget to fetch configuration from the metadata service."
    tags = "attack.privilege_escalation, attack.credential_access, attack.t1528, attack.t1552.004, cloud, gcp"
    tactic = "TA0004, TA0006"
    technique = "T1528, T1552.004"

  events:
    $e.metadata.event_type = "GCP_AUDIT_LOG"
    $e.security_result.action = "ALLOW"

    (
      // Scenario 1: Cloud Function created or updated with a service account.
      // This is a broad indicator, as it's a common administrative action.
      (
        $e.metadata.product_name = "cloudfunctions.googleapis.com" and
        (
          $e.metadata.product_event_type = "google.cloud.functions.v1.CloudFunctionsService.CreateFunction" or
          $e.metadata.product_event_type = "google.cloud.functions.v1.CloudFunctionsService.UpdateFunction"
        ) and
        // Check if a service account is being attached to the function.
        $e.target.resource.attribute.service_account_email != ""
      )
      or
      // Scenario 2: Compute Instance created with a suspicious startup script for credential exfiltration.
      (
        $e.metadata.product_name = "compute.googleapis.com" and
        $e.metadata.product_event_type = "v1.compute.instances.insert" and
        // Check that at least one service account is being attached.
        $e.target.resource.attribute.service_accounts != null and
        // Check for a startup script that accesses the metadata service and uses common exfiltration tools.
        any m in $e.target.resource.attribute.metadata: (
          m.key = "startup-script" and
          re.regex(m.value, `metadata\.google\.internal`) and
          re.regex(m.value, `(?i)curl|wget|Invoke-WebRequest`)
        )
      )
    )
    // To reduce noise, consider filtering for non-approved principals or projects.
    // For example: not $e.principal.user.userid in %gcp_approved_automation_principals

  outcome:
    $risk_score = 60
    $principal_ip = array_distinct($e.principal.ip)
    $principal_user_id = array_distinct($e.principal.user.userid)
    $target_project_id = array_distinct($e.target.resource.attribute.project_id)
    $target_resource_name = array_distinct($e.target.resource.name)
    $target_resource_type = array_distinct($e.target.resource.type)
    $method_name = array_distinct($e.metadata.product_event_type)

    // Extract the service account being attached for analyst review.
    $attached_service_account = if(
        $e.target.resource.attribute.service_account_email,
        array_distinct($e.target.resource.attribute.service_account_email),
        array_distinct($e.target.resource.attribute.service_accounts[0].email)
    )

    // Extract the full startup script if it's a compute instance event.
    $startup_script = array_distinct(
        for $m in $e.target.resource.attribute.metadata:
            if($m.key = "startup-script", $m.value, "")
    )

  condition:
    $e
}
