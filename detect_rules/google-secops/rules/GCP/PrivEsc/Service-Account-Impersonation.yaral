rule gcp_service_account_impersonation {
  meta:
    author = "RW"
    date = "2025-08-20"
    description = "Detects when a Google Cloud Platform (GCP) service account impersonates another service account to generate an access token. This can be an indicator of a privilege escalation attempt where an attacker, having compromised an account with token creation permissions, is attempting to escalate privileges by impersonating a more powerful service account."
    false_positives = "Legitimate automation or administrative tasks may perform service account impersonation. This is common in CI/CD pipelines or infrastructure-as-code (IaC) deployments. Consider adding known-good principal and target service account pairs to an exception list."
    tags = "GCP, IAM, PRIVILEGE_ESCALATION"
    tactic = "TA0004"
    technique = "T1484"

  events:
    // Event for successful impersonation attempts
    $success.metadata.event_type = "GCP_IAM_AUDIT"
    $success.metadata.product_event_type = "google.iam.credentials.v1.IAMCredentials.GenerateAccessToken"
    $success.security_result.action = "ALLOW"
    // Capture the principal (caller) and target (impersonated) service accounts
    $success.principal.user.userid = $principal_user
    $success.target.user.userid = $target_user
    $success.principal.ip = $ip
    // Ensure both principal and target are service accounts
    re.regex($success.principal.user.userid, `\.gserviceaccount\.com$`)
    re.regex($success.target.user.userid, `\.gserviceaccount\.com$`)
    // Ensure the service account is not generating a token for itself
    $success.principal.user.userid != $success.target.user.userid

    // Event for failed impersonation attempts
    $failure.metadata.event_type = "GCP_IAM_AUDIT"
    $failure.metadata.product_event_type = "google.iam.credentials.v1.IAMCredentials.GenerateAccessToken"
    $failure.security_result.action = "BLOCK"
    // Capture the principal (caller) and target (impersonated) service accounts
    $failure.principal.user.userid = $principal_user
    $failure.target.user.userid = $target_user
    $failure.principal.ip = $ip
    // Ensure both principal and target are service accounts
    re.regex($failure.principal.user.userid, `\.gserviceaccount\.com$`)
    re.regex($failure.target.user.userid, `\.gserviceaccount\.com$`)
    // Ensure the service account is not generating a token for itself
    $failure.principal.user.userid != $failure.target.user.userid

  match:
    // Group events by the calling service account and source IP over a 10 minute window
    $principal_user, $ip over 10m

  outcome:
    // Risk score is higher for a successful impersonation
    $risk_score = if(#success >= 1, 60, 40)
    $principal_user_id = array_distinct($principal_user)
    $target_user_id = array_distinct($target_user)
    $principal_ip = array_distinct($ip)
    $user_agent = array_distinct($success.network.http.user_agent, $failure.network.http.user_agent)
    $successful_impersonations = count($success.metadata.id)
    $failed_impersonations = count($failure.metadata.id)
    $event_count = $successful_impersonations + $failed_impersonations

  condition:
    // Alert on a single successful impersonation or 3 or more failed attempts
    #success >= 1 or #failure >= 3
}
