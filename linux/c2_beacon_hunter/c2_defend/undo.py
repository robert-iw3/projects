#!/usr/bin/env python3
"""
==============================================================================
Script Name: undo.py
Epic:        1 - Closed-Loop Active Response (Iteration 2.8.1)
Description: Rollback utility for false positives. Supports firewalld, ufw,
             and iptables. Reads the blocklist.txt generated by the
             c2_defend daemon to cleanly remove blackhole rules.
Story:       1.4 (Safe rollbacks)
==============================================================================
"""

import os
import sys
import subprocess
from pathlib import Path

# Configuration
BLOCKLIST = Path("blocklist.txt")

def remove_firewall_rule(line):
    """
    Parses a blocklist entry and removes the associated firewall rule.
    Format: timestamp|firewall_type|zone|ip|port
    """
    try:
        parts = line.strip().split("|")
        # Handle different blocklist formats (with or without zone/port)
        if len(parts) == 5:
            ts, fw_type, zone, ip, port = parts
        elif len(parts) == 3:
            ts, fw_type, ip = parts
            zone, port = "public", "0"
        else:
            return

        print(f"[*] Reversing {fw_type} block for {ip}...")

        if fw_type == "firewalld":
            # Reconstruct the rich rule used in defender.py
            if port == "0":
                rule = f'rule family="ipv4" source address="{ip}" drop'
            else:
                rule = f'rule family="ipv4" source address="{ip}" port port="{port}" protocol="tcp" drop'

            subprocess.run(["firewall-cmd", "--permanent", f"--zone={zone}", "--remove-rich-rule", rule], check=True, capture_output=True)
            subprocess.run(["firewall-cmd", "--reload"], check=True, capture_output=True)

        elif fw_type == "ufw":
            if port == "0":
                subprocess.run(["ufw", "delete", "deny", "from", ip], check=True, capture_output=True)
            else:
                subprocess.run(["ufw", "delete", "deny", "from", ip, "to", "any", "port", port], check=True, capture_output=True)

        elif fw_type == "iptables":
            if port == "0":
                subprocess.run(["iptables", "-D", "INPUT", "-s", ip, "-j", "DROP"], check=True)
                subprocess.run(["iptables", "-D", "OUTPUT", "-d", ip, "-j", "DROP"], check=True)
            else:
                subprocess.run(["iptables", "-D", "INPUT", "-s", ip, "-p", "tcp", "--dport", port, "-j", "DROP"], check=True)

        print(f"[+] Successfully removed block for {ip}")
    except Exception as e:
        print(f"[!] Failed to remove block for {line.strip()}: {e}")

def main():
    # Privilege Check
    if os.geteuid() != 0:
        print("Fatal: This utility must be run as root to modify firewall rules.")
        sys.exit(1)

    if not BLOCKLIST.exists() or BLOCKLIST.stat().st_size == 0:
        print("No active blocks found in blocklist.txt.")
        return

    with open(BLOCKLIST, "r") as f:
        blocks = f.readlines()

    print(f"=== Active Containment Rules ({len(blocks)}) ===")
    for i, line in enumerate(blocks):
        parts = line.strip().split("|")
        if len(parts) >= 3:
            ip = parts[3] if len(parts) == 5 else parts[2]
            fw = parts[1]
            print(f"{i+1:2d}. Target: {ip:<15} | Manager: {fw}")

    confirm = input("\nRemove ALL blocks and restore network access? (y/N): ").strip().lower()

    if confirm == "y":
        for line in blocks:
            remove_firewall_rule(line)

        # Clear the blocklist file
        BLOCKLIST.unlink()
        print("\n[+] Rollback complete. All rules removed.")
    else:
        print("\n[-] Operation cancelled.")

if __name__ == "__main__":
    main()